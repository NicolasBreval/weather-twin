package org.nbreval.weather_twin.gateway.test;

import java.nio.file.Paths;
import java.time.Duration;
import java.util.UUID;

import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Test;
import org.nbreval.weather_twin.gateway.shared.domain.model.SensorNotification;
import org.nbreval.weather_twin.gateway.test.util.HttpUtils;
import org.nbreval.weather_twin.gateway.test.util.TypeUtils;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.event.EventListener;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.context.TestPropertySource;
import org.springframework.util.FileSystemUtils;

import reactor.core.publisher.Sinks;
import reactor.test.StepVerifier;

/**
 * Test class used to ensure the MQTT gateway works correctly
 */
@TestPropertySource(properties = "logging.level.org.nbreval.weather_twin=DEBUG")
@SpringBootTest
public class EntrypointMqttTests {

  /**
   * Sink object used to redirect MQTT listener events and process them later
   */
  private static final Sinks.Many<SensorNotification> sink = Sinks.many().unicast().onBackpressureBuffer();

  /**
   * Folder where store persisted elements from MQTT server
   */
  private static final String MQTT_PERSISTENCE_PATH = "data/%s".formatted(UUID.randomUUID().toString());

  /**
   * Port used to configure MQTT server
   */
  private static final int MQTT_PORT = HttpUtils.getRandomPort();

  /**
   * Method used to configure Spring application without an application.yml file.
   * 
   * @param registry Object used to configure each property
   */
  @DynamicPropertySource
  static void setupProperties(DynamicPropertyRegistry registry) {
    registry.add("entrypoint.listener.type", () -> "mqtt");
    registry.add("entrypoint.listener.mqtt.port", () -> MQTT_PORT);
    registry.add("entrypoint.listener.mqtt.persistence-path", () -> MQTT_PERSISTENCE_PATH);
  }

  /**
   * Method used to clean the MQTT persistence folder, to ensure the next test
   * which needs the MQTT server starts with a clean environment
   */
  @AfterAll
  static void teardown() {
    FileSystemUtils.deleteRecursively(Paths.get(MQTT_PERSISTENCE_PATH).toFile());
  }

  /**
   * Util class used to listen for all events generated by MQTT listener. This
   * class allows to store all events in the {@link sink} and use them in a test
   */
  @TestConfiguration
  static class TestEvents {

    /**
     * Listen for each event sent from MQTT server and stores it in the {@link sink}
     * 
     * @param event
     */
    @EventListener
    public void handleSensorNotification(SensorNotification event) {
      sink.tryEmitNext(event);
    }
  }

  /**
   * Test used to ensure the MQTT listener propagates the received messages
   * correctly
   * 
   * @throws MqttException Thrown if occurs any error during MQTT connection
   */
  @Test
  public void checkEvents() throws MqttException {
    try (var client = new MqttClient("tcp://localhost:%d".formatted(MQTT_PORT), "test-client")) {
      client.connect();

      StepVerifier.create(sink.asFlux())
          .then(() -> {
            try {
              client.publish("device1/sensor1/1757225005830",
                  new MqttMessage(TypeUtils.doubleToBytes(23.5)));
            } catch (Exception e) {
              throw new RuntimeException(e);
            }
          })
          .expectNextMatches(e -> e.getDeviceId().equals("device1") &&
              e.getSensorId().equals("sensor1") &&
              e.getUtcTimestamp() == 1757225005830L &&
              e.getMeasure() == 23.5)
          .thenCancel()
          .verify(Duration.ofSeconds(5));

      client.disconnect();
    }
  }
}
